{% extends "layout_tpnd.html" %}

{% block subsubheader %}
   <meta name="description" content="Tutorial for Publish &amp; Subscribe over WebSockets using Autobahn.oss.">
{% endblock %}


{% block pagecontent %}

   <div class="pagewrapper">

      <a name="top"></a>
      <h1>Publish &amp; Subscribe with {{ autobahnjs() }}</h1>

         <p>
            The goal of this tutorial is to introduce publish and subscribe (PubSub) messaging with {{ autobahnjs() }}.
         </p>
         <p>
            Publish &amp; Subscribe is a messaging pattern in which publishers send events to a server, and this server distributes the events to subscribers.
            Publishers and subscribers are decoupled through the server: they don't have any knowledge about each other. The connection between the two is only established via the topics.<br>
            Sending and receiving of events  are asynchronous.
         </p>
         <p>
            Publish &amp; Subscribe can be used for a huge variety of applications, e.g. chat, news updates, or, with low-latency implementations,  distribution of real-time data.<br>
            It scales well, and the fact that subscriptions need not be handled by publishers means that publishing is a light-weight process that can easily be added to applications.
         </p>

         <p>
            In {{ autobahnjs() }}, PubSub is implemented based on {{ wamp(short = false) }}, an open protocol that enables both PubSub and Remote Procedure Calls (RPC) over WebSocket. There is also a <a href="{{ url_for('page_js_tutorials_rpc') }}">tutorial for how to do RPC</a> using {{ autobahnjs() }}.
         </p>


         <p>
            In this tutorial well will create a small web app that consists of two clients which connect to a WAMP server. One of the clients publishes to a topic to which the other client subscribes himself. The sent and received events are logged in the respective browser consoles.
         </p>


      <h2>Prerequisites</h2>

         <p>
            For this tutorial, you will need
            <ul>
               <li>
                  a modern Web Browser with WebSockets to run the clients, and
               </li>
               <li>
                  <a href="http://crossbar.io/">Crossbar.io</a>, a WAMP application router to provide the RPC routing.
               </li>
            </ul>
         </p>

         <a class="awh_up_developers" href="#top">Up</a>
         <br/>


      <h2>The WAMP RPC demo server</h2>

      <p>
         Browsers can only act as WebSockets clients, so we need something external to the browser to act as a sever. For this we use Crossbar.io, an open source application server.
      </p>

      <p>
         For the installation of Crossbar.io, see the <a href="https://github.com/crossbario/crossbar/wiki/Getting-Started">detailed instructions</a> at the project GitHub repo.
      </p>

      <p>
         Once you've installed Crossbar.io, open a command shell, create a test directory, initialize Crossbar.io and start it.
      </p>

      {{ beginshell() }}
mkdir test1
cd test 1
crossbar init
crossbar start
      {{ endshell() }}

      <p>
         That's it - Crossbar.io is running, ready to route our RPCs. (It runs until you break out from the Python interpreter - Ctrl-C/D/Z depending on your platform).
      </p>
      <p>
         With this we have all the non-JavaScript stuff out of the way. From now on it's web technologies only.
      </p>
      <a class="awh_up_developers" href="#top">Up</a>
         <br/>

      <h2>The HTML</h2>

      <p>
         The HTML is very simple in for both the publisher and the subscriber.
      </p>

      <p>
         For the publisher, we just need something which identifies the browser tab to us, plus, of course, load the WAMP library, {{ autobahnjs() }}.
      </p>

      <div class="codeex">
         <script type="syntaxhighlighter" class="brush: xml; toolbar: false; auto-links: false;"><![CDATA[
<!DOCTYPE html>
<head>
   <meta charset="UTF-8">
   <title>AutobahnJS PubSub Publisher</title>
</head>
<html>
   <body>
      <h1>AutobahnJS PubSub Publisher</h1>
      <p>Open JavaScript console to watch output.</p>
      <script src="https://autobahn.s3.amazonaws.com/autobahnjs/latest/autobahn.min.jgz">&lt;/script>
   </body>
</html>
            ]]>
         </script>
      </div>

      <p>
         For the subscriber, all that changes are some title strings, i.e. "AutobahnJS PubSub Publisher" becomes "AutobahnJS PubSub Subscriber":
      </p>

      <div class="codeex">
         <script type="syntaxhighlighter" class="brush: xml;  highlight: [4, 8]; toolbar: false; auto-links: false;"><![CDATA[
<!DOCTYPE html>
<head>
   <meta charset="UTF-8">
   <title>AutobahnJS PubSub Subscriber</title>
</head>
<html>
   <body>
      <h1>AutobahnJS PubSub Subscriber</h1>
      <p>Open JavaScript console to watch output.</p>
      <script src="https://autobahn.s3.amazonaws.com/autobahnjs/latest/autobahn.min.jgz">&lt;/script>
      <script src="backend.js">&lt;/script>
   </body>
</html>
            ]]>
         </script>
      </div>


      <h2>The JavaScript</h2>

      <p>
         To make the demo quick to run in the browser, the JavaScript is included as an inline script in the publisher and subscriber client HTML files.
      </p>
      <ul>
         <li>
            <a href="{{ url_for('static', filename='file/autobahnjs_pubsub_publisher.html') }}">Publisher</a>
         </li>
         <li>
            <a href="{{ url_for('static', filename='file/autobahnjs_pubsub_subscriber.html') }}">Subscriber</a>
         </li>
      </ul>
      <p>
         The JavaScript on its own can, however, also be run in Node.js. In this case, use
      </p>
      <ul>
         <li>
            <a href="{{ url_for('static', filename='file/autobahnjs_pubsub_publisher.js') }}">Publisher</a>
         </li>
         <li>
            <a href="{{ url_for('static', filename='file/autobahnjs_pubsub_subscriber.js') }}">Subscriber</a>
         </li>
      </ul>
      <p>
         The only difference is that in the browser, {{ autobahnjs() }} is loaded via a script tag, while in Node.js we need to include it via node's dependency management.
      </p>
      <p>
         In order to be freely movable, we can add code which covers both use cases:
      </p>
      <div class="codeex">
         <pre class="brush: javascript; toolbar: false; auto-links: false;">
            try {
               var autobahn = require('autobahn');
            } catch (e) {
               // when running in browser, AutobahnJS will
               // be included without a module system
            }
         </pre>
      </div>

      <h2>Connecting to the Server</h2>

      <p>
         The first thing we need to do if we want to use PubSub over WebSockets is to establish a WebSocket connection. WebSocket is built into modern browsers, so in principle we could use the built-in API for this.
      </p>
      <p>
         Establishing the connection itself is quite straight forward, but WebSockets is  a low-level protocol. It does not provide any in-built features for publish and subscribe. For these we use WAMP.
      </p>
      <p>
         {{ autobahnjs() }} not only implements WAMP, but also some comfort features for handling WebSocket connections. Because of this all our interaction for the connection is via {{ autobahnjs() }}.
      </p>
      <p>
         The code to establish a WAMP/WebSocket connection is the same for both the publisher and the subscriber.
      </p>

      <div class="codeex">
         <pre class="brush: javascript; highlight: [2, 8, 13]; toolbar: false; auto-links: false;">
            // Set up WAMP connection to router
            var connection = new autobahn.Connection({
               url: 'ws://localhost:8080/ws',
               realm: 'tutorialpubsub'}
            );

            // Set up 'onopen' handler
            connection.onopen = function (session) {
               // code to execute on connection open goes here
            };

            // Open connection
            connection.open();
         </pre>
      </div>

      <p>
         What we do here is:
      </p>
      <ul>
         <li>
            We define (line 2) a WAMP/WebSocket connection with minimum amount of necessary parameters
            <ul>
               <li>
                  The WebSockets address to connect to. This starts with the WebSockets protocol prefix 'ws' (instead of 'http' for regular web traffic), and here is the localhost on port 9000. It could equally be the IP of the machine you run the server on.
               </li>
               <li>
                  The WAMP realm to connect to. Realms are used to group connections to a WAMP server together, and to e.g. apply permissions to them. With our demo server, we are free to chose a realm name.
               </li>
            </ul>
         </li>
         <li>
            We set up an 'onopen' handler, i.e. a function to execute once a connection has been established (starting at line 8). This is passed an object through which we can interact with the established WAMP/WebSocket session.
         </li>
         <li>
            We open the WAMP/WebSocket connection (line 13).
         </li>
      </ul>

      <p>
         The options dictionary for the connection accepts further optional arguments. For this tutorial, none of these are relevant.
      </p>

      <a class="awh_up_developers" href="#top">Up</a>
         <br/>


      <h2>On connect</h2>

      <p>
         Once the connection is established, the code in the 'onopen' handler is executed.
      </p>

      <p>
         For the <strong>publisher</strong> this is:
      </p>

      <div class="codeex">
         <pre id="code" class="brush: javascript; highlight: [6]; toolbar: false; auto-links: false;">
            // Start publishing events
            var counter = 0;

            setInterval(function () {
               console.log("publishing to topic 'com.myapp.topic1': " + counter);
               session.publish('com.myapp.topic1', [counter]);
               counter += 1;
            }, 1000);
         </pre>
      </div>

      <p>
         What we do here is:
      </p>
      <ul>
         <li>
            The publication of the event itself if just a single line (line 6). The publication is for a topic, 'com.myapp.topic1'. WAMP uses URIs (with the notation following the Java package naming conventions) to identify topics. The publication also has an optional payload
         </li>
         <li>
            The payload here is a counter, which we've defined in line 2 and which we increment after each publish (line 7).
         </li>
         <li>
            We want to publish more than once, so we create an interval time to wrap the publication.
         </li>
         <li>
            Since we want some output in the publisher's console, we log the fact that we're publishing as well as the current counter value (line 5).
         </li>
      </ul>

      <p>
         For the <strong>subscriber</strong> this is:
      </p>

      <div class="codeex">
         <pre id="code" class="brush: javascript; highlight: [7]; toolbar: false; auto-links: false;">
         // Define an event handler
         function onEvent(args) {
            console.log("Event received ", args);
         }

         // Subscribe to a topic
         session.subscribe('com.myapp.topic1', onEvent);
         </pre>
      </div>

      <p>
         What we do here is:
      </p>
      <ul>
         <li>
            We define a handler for subscription events (line 2). Here, this just logs the fact that we have received an event plus the event payload.
         </li>
         <li>
            We then subscribe to the topic (line 7). Arguments are the subscription topic (identified by a URI) and the subscription event handler (the function we've just defined).
         </li>
      </ul>

      <a class="awh_up_developers" href="#top">Up</a>
         <br/>


      <h2>Summary & Beyond</h2>
      <p>This tutorial gave an overview how simple PubSub messaging is with {{ autobahnjs() }} - no more than a line of code each for either subscribing and publishing.</p>
      <p>We encourage you to play around with the WAMP demo server and with the demo app. Run it on different machines. Add more event data. Use the received events to trigger functions that do more than just log things.
      <p>
         If you're interested, the <a href="{{ url_for('page_home')}}">PubSub Tutorial</a> shows you an equally quick and easy start into publish & subscribe with {{ autobahnjs() }}. Or go to the <a href="{{ url_for('page_python_examples')}}">Python examples</a> to start exploring how the WAMP demo server works.
      </p>


      <a class="awh_up_developers" href="#top">Up</a>
         <br/>
         <br>
         <br>


   </div>

{% endblock %} <!-- pagecontent -->
